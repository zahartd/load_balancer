# Тестовое задание для Cloud.ru Camp

**Цель:** Реализовать простой балансировщик нагрузки, который принимает входящие HTTP-запросы и распределяет их по пулу бэкенд-серверов. Задание будет оценивать ваши знания Go, умение работать с горутинами, сетевыми запросами, конфигурацией и логированием. В задании присутствует несколько частей, но даже если ты сделал(а) всего одну часть, смело присылай решение, мы его в любом случае рассмотрим и дадим обратную связь. Дополнительные пункты для размышления не являются обязательными, а служат скорее для подсказки возможных вариантов реализации или расширения проекта.

## 1. Вопросы для разогрева

1. Опишите самую интересную задачу в программировании, которую вам приходилось решать?
2. Расскажите о своем самом большом факапе? Что вы предприняли для решения проблемы?
3. Каковы ваши ожидания от участия в буткемпе?

---

## 2. Разработка HTTP-балансировщика нагрузки на Go
### Часть 1. Балансировщик нагрузки
**Основной функционал:**
- Реализовать HTTP-сервер, который принимает входящие запросы (например, на порту 8080).
- При получении запроса балансировщик должен пересылать его на один из заранее заданных бэкенд-серверов. Адреса серверов можно задавать через конфигурационный файл или переменные окружения.
- Использовать стандартный HTTP-пакет Go (net/http) для работы с запросами и для переадресации (reverse proxy, например, с использованием пакета net/http/httputil).

**Распределение запросов:**
- Реализовать алгоритм распределения запросов по бэкендам (минимум – round-robin).
- Балансировщик должен корректно обрабатывать ситуацию, когда один или несколько бэкендов недоступны (выводить понятное сообщение об ошибке или перенаправлять запросы на работающие серверы).

**Параллелизм и конкурентность:**
- Обеспечить одновременную обработку нескольких запросов с использованием горутин.
- Гарантировать корректную работу в условиях конкурентных вызовов (избегать гонок данных).

**Обработка ошибок:**
- Реализовать обработку ошибок при обращении к бэкендам.
- Выводить понятные сообщения ошибок в лог (например, при недоступности сервера).

**Логирование:**
- Реализовать базовое логирование входящих запросов, ошибок и событий (например, смены бэкенда при сбое одного из серверов). Можно использовать стандартный пакет log или другую библиотеку для логирования.

**Конфигурация:**
- Балансировщик должен получать список бэкендов и порт для прослушивания через внешний конфигурационный файл (JSON или YAML) или через параметры командной строки.
- Конфигурация должна быть независима от кода (изменения конфигурации без перекомпиляции).

### Часть 2. Реализация Rate-Limiting
Требуется разработать модуль для ограничения частоты запросов (rate-limiting) на основе алгоритма Token Bucket. Модуль должен защищать внутренние сервисы от перегрузок, обеспечивать честное распределение ресурсов между клиентами и корректно обрабатывать высокую нагрузку.

**Функциональные требования:**

**Реализация алгоритма Token Bucket:**
- Каждому клиенту (IP или API-ключ) выделяется отдельный **bucket** токенов.
- Настройки bucket: количество токенов (емкость), скорость пополнения.
- Запрос считается допустимым, если в bucket клиента есть токен. В противном случае — отклоняется.

**Гранулярное ограничение:**
- Отслеживать состояние каждого клиента (IP/API-ключ)
- Поддерживать возможность настройки разных лимитов для разных клиентов.
- Настройки для разных клиентов можно сохранять в базе данных

**Автоматическое пополнение токенов:**
- Использовать `time.Ticker` для периодического пополнения токенов в buckets.
- Гарантировать атомарность операций с токенами (проверка, извлечение, пополнение).

**Конкурентность:**
- Методы обработки запросов и обновления состояния buckets должны быть потокобезопасными.
- Обеспечить минимальные блокировки для максимизации производительности.

Требуется подготовить README с описанием сборки и запуска проекта.

### Будет здорово, если:
- Архитектура проекта будет модульной: разделите код на логически обособленные пакеты (например, для логики распределения, работы с конфигурацией и реализации HTTP-сервера).
- Приветствуется чистота кода, понятное и подробное комментирование, а также применение интерфейсов для упрощения замены реализаций.
- Оценка задания будет проводиться не только на основе реализованного функционала, но и на основе качества кода (структурирование, тестируемость, документация).
- Напишите Dockerfile и docker-compose.yml для развертывания сервиса и БД 
- Добавите интеграционные тесты с использованием `go test -bench=. -race`.
- Пример нагрузки через Apache Bench (`ab -n 5000 -c 1000 http://localhost:8080/`).


### Дополнительные пункты для размышления
**Поддержка нескольких алгоритмов распределения:**
- Помимо round-robin, реализовать или предусмотреть возможность использования алгоритмов «least connections» или случайного распределения запросов.

**Здоровье бэкендов (Health Checks):**
- Добавить механизм периодических проверок состояния каждого бэкенд-сервера.
- При обнаружении недоступного сервера временно исключать его из пула, а при восстановлении работы возвращать обратно.

**Graceful Shutdown:**
- Реализовать корректное завершение работы балансировщика (обработка сигнала SIGINT или SIGTERM), чтобы завершить обработку текущих запросов без потери данных.

**CRUD для управления клиентами:**
- API для добавления/удаления клиентов (IP/API-ключей) и настройки их лимитов.
- Пример эндпоинта:
    `POST /clients { "client_id": "user1", "capacity": 100, "rate_per_sec": 10 }`

**Персистентность:**
- Сохранять состояние клиентов (текущие токены, настройки) в БД или файле.
- Использовать конфигурационный файл для дефолтных лимитов.

**Обработка ошибок:**
- Возвращать структурированные JSON-ошибки с кодом и описанием.
- Пример:
    `{ "code": 429, "message": "Rate limit exceeded" }`